// VTableHunter.java - Find virtual function tables for class hierarchy mapping
// Run in Ghidra's Script Manager
//
// VTables help identify:
// 1. Class hierarchies (inheritance)
// 2. Virtual function locations
// 3. Object types at runtime
//
// @category Analysis
// @author COA Script Extender Project

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.address.*;
import ghidra.program.model.mem.*;
import ghidra.program.model.data.*;
import java.util.*;
import java.io.*;

public class VTableHunter extends GhidraScript {

    private PrintWriter output;
    
    // Discovered vtables
    private List<VTable> vtables = new ArrayList<>();
    
    static class VTable {
        Address address;
        String probableName;
        List<Address> functions = new ArrayList<>();
        int referenceCount;
        Set<String> hints = new HashSet<>();
    }

    @Override
    public void run() throws Exception {
        File outputFile = new File(getProgramFile().getParentFile(), "coa_vtables.txt");
        output = new PrintWriter(new FileWriter(outputFile));
        
        println("===========================================");
        println("VTableHunter - Finding Virtual Function Tables");
        println("===========================================");
        
        output.println("# Call to Arms: Virtual Function Tables");
        output.println("# Generated by VTableHunter.java");
        output.println();
        
        // Find vtables in read-only data sections
        println("Phase 1: Scanning for vtable patterns...");
        findVTablePatterns();
        
        // Analyze vtable references
        println("Phase 2: Analyzing vtable references...");
        analyzeVTableReferences();
        
        // Output results
        outputResults();
        
        // Generate vtable header
        generateVTableHeader();
        
        output.close();
        
        println();
        println("===========================================");
        println("COMPLETE! Found " + vtables.size() + " vtables");
        println("Results: " + outputFile.getAbsolutePath());
        println("===========================================");
    }
    
    private void findVTablePatterns() throws Exception {
        Memory memory = currentProgram.getMemory();
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        
        // Look in .rdata and similar sections
        for (MemoryBlock block : memory.getBlocks()) {
            String name = block.getName().toLowerCase();
            if (!name.contains("rdata") && !name.contains("rodata") && !name.contains("const")) {
                continue;
            }
            
            println("Scanning: " + block.getName());
            
            Address addr = block.getStart();
            Address end = block.getEnd();
            
            while (addr.compareTo(end) < 0 && !monitor.isCancelled()) {
                // Check if this looks like a vtable
                VTable vtable = tryParseVTable(addr, funcMgr);
                if (vtable != null && vtable.functions.size() >= 3) {
                    vtables.add(vtable);
                    // Skip past this vtable
                    addr = addr.add(vtable.functions.size() * 8);
                } else {
                    addr = addr.add(8);
                }
            }
        }
        
        println("Found " + vtables.size() + " potential vtables");
    }
    
    private VTable tryParseVTable(Address addr, FunctionManager funcMgr) throws Exception {
        Memory memory = currentProgram.getMemory();
        VTable vtable = new VTable();
        vtable.address = addr;
        
        // A vtable is a sequence of function pointers
        // Usually starts with destructor or first virtual method
        
        Address current = addr;
        int consecutiveFunctions = 0;
        int nullsAllowed = 2; // Some vtables have null entries
        int nullsSeen = 0;
        
        while (consecutiveFunctions < 100) { // Reasonable limit
            try {
                long value = memory.getLong(current);
                
                if (value == 0) {
                    nullsSeen++;
                    if (nullsSeen > nullsAllowed) break;
                    current = current.add(8);
                    continue;
                }
                
                Address funcAddr = currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(value);
                
                // Check if this points to executable code
                MemoryBlock targetBlock = memory.getBlock(funcAddr);
                if (targetBlock == null || !targetBlock.isExecute()) {
                    break; // Not a function pointer
                }
                
                // Check if there's a function here
                Function func = funcMgr.getFunctionAt(funcAddr);
                if (func == null) {
                    func = funcMgr.getFunctionContaining(funcAddr);
                }
                
                if (func != null || targetBlock.isExecute()) {
                    vtable.functions.add(funcAddr);
                    consecutiveFunctions++;
                    nullsSeen = 0;
                } else {
                    break;
                }
                
                current = current.add(8);
                
            } catch (Exception e) {
                break;
            }
        }
        
        if (vtable.functions.size() >= 3) {
            return vtable;
        }
        return null;
    }
    
    private void analyzeVTableReferences() throws Exception {
        ReferenceManager refMgr = currentProgram.getReferenceManager();
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        
        for (VTable vtable : vtables) {
            // Count references to this vtable
            ReferenceIterator refs = refMgr.getReferencesTo(vtable.address);
            while (refs.hasNext()) {
                Reference ref = refs.next();
                vtable.referenceCount++;
                
                // Check the function that references this vtable
                Function func = funcMgr.getFunctionContaining(ref.getFromAddress());
                if (func != null) {
                    String funcName = func.getName().toLowerCase();
                    
                    // Look for class name hints
                    if (funcName.contains("unit")) vtable.hints.add("Unit");
                    if (funcName.contains("vehicle")) vtable.hints.add("Vehicle");
                    if (funcName.contains("weapon")) vtable.hints.add("Weapon");
                    if (funcName.contains("squad")) vtable.hints.add("Squad");
                    if (funcName.contains("team")) vtable.hints.add("Team");
                    if (funcName.contains("ai")) vtable.hints.add("AI");
                    if (funcName.contains("entity")) vtable.hints.add("Entity");
                    if (funcName.contains("object")) vtable.hints.add("Object");
                    if (funcName.contains("game")) vtable.hints.add("Game");
                    if (funcName.contains("world")) vtable.hints.add("World");
                    if (funcName.contains("manager")) vtable.hints.add("Manager");
                    if (funcName.contains("controller")) vtable.hints.add("Controller");
                    if (funcName.contains("path")) vtable.hints.add("Path");
                    if (funcName.contains("move")) vtable.hints.add("Movement");
                    if (funcName.contains("attack")) vtable.hints.add("Attack");
                    if (funcName.contains("target")) vtable.hints.add("Target");
                }
            }
            
            // Generate probable name
            if (!vtable.hints.isEmpty()) {
                vtable.probableName = String.join("_", vtable.hints) + "_VTable";
            } else {
                vtable.probableName = "Unknown_VTable_" + vtable.address.toString();
            }
        }
        
        // Sort by reference count (most referenced = most important)
        vtables.sort((a, b) -> b.referenceCount - a.referenceCount);
    }
    
    private void outputResults() {
        output.println("========================================");
        output.println("DISCOVERED VTABLES (sorted by reference count)");
        output.println("========================================");
        output.println();
        
        int shown = 0;
        for (VTable vtable : vtables) {
            if (vtable.referenceCount < 2 && shown > 50) continue; // Skip low-use vtables
            
            output.println(String.format("VTable: %s", vtable.probableName));
            output.println(String.format("  Address: %s (offset: 0x%s)", 
                          vtable.address, formatOffset(vtable.address)));
            output.println(String.format("  References: %d", vtable.referenceCount));
            output.println(String.format("  Virtual functions: %d", vtable.functions.size()));
            
            // List first few functions
            output.println("  Methods:");
            for (int i = 0; i < Math.min(10, vtable.functions.size()); i++) {
                Address funcAddr = vtable.functions.get(i);
                Function func = currentProgram.getFunctionManager().getFunctionAt(funcAddr);
                String funcName = func != null ? func.getName() : "FUN_" + funcAddr.toString();
                output.println(String.format("    [%d] %s @ %s", i, funcName, funcAddr));
            }
            if (vtable.functions.size() > 10) {
                output.println(String.format("    ... and %d more", vtable.functions.size() - 10));
            }
            
            output.println();
            shown++;
        }
        
        output.println();
        output.println("Total vtables found: " + vtables.size());
        output.println("Vtables with 5+ references: " + 
                      vtables.stream().filter(v -> v.referenceCount >= 5).count());
    }
    
    private void generateVTableHeader() throws Exception {
        File headerFile = new File(getProgramFile().getParentFile(), "coa_vtables.h");
        PrintWriter header = new PrintWriter(new FileWriter(headerFile));
        
        header.println("/**");
        header.println(" * Call to Arms: Gates of Hell - Virtual Function Tables");
        header.println(" * Auto-generated by VTableHunter.java");
        header.println(" */");
        header.println();
        header.println("#pragma once");
        header.println("#include <cstdint>");
        header.println();
        header.println("namespace COA {");
        header.println("namespace VTables {");
        header.println();
        
        // Output vtable offsets
        int count = 0;
        for (VTable vtable : vtables) {
            if (vtable.referenceCount < 3) continue; // Skip rarely-used
            if (count++ > 100) break; // Limit output
            
            String safeName = vtable.probableName.replaceAll("[^a-zA-Z0-9_]", "_");
            header.println(String.format("constexpr uintptr_t %s = 0x%s; // %d refs, %d methods",
                          safeName, formatOffset(vtable.address),
                          vtable.referenceCount, vtable.functions.size()));
        }
        
        header.println();
        header.println("} // namespace VTables");
        header.println("} // namespace COA");
        
        header.close();
        println("Generated vtable header: " + headerFile.getAbsolutePath());
    }
    
    private String formatOffset(Address addr) {
        String full = addr.toString();
        if (full.startsWith("140")) {
            return "0" + full.substring(3);
        } else if (full.startsWith("14")) {
            return full.substring(2);
        }
        return full;
    }
}
