// CrossReferenceAnalyzer.java - Map function call relationships
// Run in Ghidra's Script Manager
//
// This script builds a call graph to:
// 1. Find which functions call which (for hook chains)
// 2. Identify "hub" functions that are called everywhere
// 3. Map the AI/game logic flow
//
// @category Analysis
// @author COA Script Extender Project

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.address.*;
import java.util.*;
import java.io.*;

public class CrossReferenceAnalyzer extends GhidraScript {

    private PrintWriter output;
    
    // Track function relationships
    private Map<String, Set<String>> callsTo = new HashMap<>();   // func -> functions it calls
    private Map<String, Set<String>> calledBy = new HashMap<>();  // func -> functions calling it
    private Map<String, Integer> callCount = new HashMap<>();     // how many times func is called
    
    // Key functions to analyze (from our discoveries)
    private static final String[] KEY_PREFIXES = {
        "AI_", "Parse_", "Unit_", "Vehicle_", "Weapon_", "Squad_", "Team_",
        "Game_", "Entity_", "Combat_", "Movement_", "Pathfind", "Target",
        "Damage_", "Armor_", "Attack_", "Defense_", "Morale_"
    };

    @Override
    public void run() throws Exception {
        File outputFile = new File(getProgramFile().getParentFile(), "coa_xref_analysis.txt");
        output = new PrintWriter(new FileWriter(outputFile));
        
        println("===========================================");
        println("CrossReferenceAnalyzer - Mapping Call Graph");
        println("===========================================");
        
        output.println("# Call to Arms: Cross-Reference Analysis");
        output.println("# Generated by CrossReferenceAnalyzer.java");
        output.println();
        
        // Phase 1: Analyze all interesting functions
        println("Phase 1: Building call graph...");
        buildCallGraph();
        
        // Phase 2: Find hub functions (highly connected)
        println("Phase 2: Finding hub functions...");
        findHubFunctions();
        
        // Phase 3: Map AI logic flow
        println("Phase 3: Mapping AI logic flow...");
        mapAIFlow();
        
        // Phase 4: Find hook chain opportunities
        println("Phase 4: Finding hook points...");
        findHookChains();
        
        // Generate summary
        generateSummary();
        
        output.close();
        
        println();
        println("===========================================");
        println("COMPLETE!");
        println("Results: " + outputFile.getAbsolutePath());
        println("===========================================");
    }
    
    private void buildCallGraph() throws Exception {
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        ReferenceManager refMgr = currentProgram.getReferenceManager();
        FunctionIterator funcIter = funcMgr.getFunctions(true);
        
        int analyzed = 0;
        while (funcIter.hasNext() && !monitor.isCancelled()) {
            Function func = funcIter.next();
            String funcName = func.getName();
            
            // Filter to interesting functions
            boolean interesting = false;
            for (String prefix : KEY_PREFIXES) {
                if (funcName.startsWith(prefix) || funcName.contains(prefix)) {
                    interesting = true;
                    break;
                }
            }
            if (!interesting) continue;
            
            // Initialize sets
            callsTo.computeIfAbsent(funcName, k -> new HashSet<>());
            calledBy.computeIfAbsent(funcName, k -> new HashSet<>());
            
            // Find all calls FROM this function
            InstructionIterator instIter = currentProgram.getListing().getInstructions(func.getBody(), true);
            while (instIter.hasNext()) {
                Instruction inst = instIter.next();
                if (inst.getMnemonicString().toLowerCase().equals("call")) {
                    Reference[] refs = inst.getReferencesFrom();
                    for (Reference ref : refs) {
                        Function calledFunc = funcMgr.getFunctionAt(ref.getToAddress());
                        if (calledFunc != null) {
                            String calledName = calledFunc.getName();
                            callsTo.get(funcName).add(calledName);
                            calledBy.computeIfAbsent(calledName, k -> new HashSet<>()).add(funcName);
                            callCount.merge(calledName, 1, Integer::sum);
                        }
                    }
                }
            }
            
            analyzed++;
            if (analyzed % 500 == 0) {
                println("  Analyzed " + analyzed + " functions...");
            }
        }
        
        println("  Total analyzed: " + analyzed);
        output.println("Functions analyzed: " + analyzed);
        output.println();
    }
    
    private void findHubFunctions() {
        output.println("========================================");
        output.println("HUB FUNCTIONS (Most called)");
        output.println("========================================");
        output.println();
        
        // Sort by call count
        List<Map.Entry<String, Integer>> sorted = new ArrayList<>(callCount.entrySet());
        sorted.sort((a, b) -> b.getValue() - a.getValue());
        
        int shown = 0;
        for (Map.Entry<String, Integer> entry : sorted) {
            if (shown++ >= 50) break;
            
            String funcName = entry.getKey();
            int count = entry.getValue();
            Set<String> callers = calledBy.getOrDefault(funcName, Collections.emptySet());
            
            output.println(String.format("%s (%d calls)", funcName, count));
            if (callers.size() <= 5) {
                for (String caller : callers) {
                    output.println("  <- " + caller);
                }
            } else {
                output.println("  Called by " + callers.size() + " functions");
            }
            output.println();
        }
    }
    
    private void mapAIFlow() {
        output.println("========================================");
        output.println("AI LOGIC FLOW");
        output.println("========================================");
        output.println();
        
        // Find AI entry points (functions not called by other AI functions)
        Set<String> aiEntryPoints = new HashSet<>();
        for (String funcName : callsTo.keySet()) {
            if (!funcName.startsWith("AI_")) continue;
            
            Set<String> callers = calledBy.getOrDefault(funcName, Collections.emptySet());
            boolean calledByAI = false;
            for (String caller : callers) {
                if (caller.startsWith("AI_")) {
                    calledByAI = true;
                    break;
                }
            }
            if (!calledByAI) {
                aiEntryPoints.add(funcName);
            }
        }
        
        output.println("AI Entry Points (not called by other AI functions):");
        for (String entry : aiEntryPoints) {
            output.println("  " + entry);
            printCallTree(entry, "    ", 3, new HashSet<>());
        }
        output.println();
    }
    
    private void printCallTree(String funcName, String indent, int depth, Set<String> visited) {
        if (depth <= 0 || visited.contains(funcName)) return;
        visited.add(funcName);
        
        Set<String> calls = callsTo.getOrDefault(funcName, Collections.emptySet());
        for (String called : calls) {
            if (called.startsWith("AI_") || called.startsWith("Parse_") || 
                called.startsWith("Unit_") || called.startsWith("Vehicle_")) {
                output.println(indent + "-> " + called);
                printCallTree(called, indent + "  ", depth - 1, visited);
            }
        }
    }
    
    private void findHookChains() {
        output.println("========================================");
        output.println("HOOK CHAIN OPPORTUNITIES");
        output.println("========================================");
        output.println();
        output.println("Functions that call multiple hookable functions:");
        output.println("(Hooking these gives access to entire subsystems)");
        output.println();
        
        // Find functions that call many other interesting functions
        List<Map.Entry<String, Set<String>>> sorted = new ArrayList<>();
        for (Map.Entry<String, Set<String>> entry : callsTo.entrySet()) {
            if (entry.getValue().size() >= 3) {
                sorted.add(entry);
            }
        }
        sorted.sort((a, b) -> b.getValue().size() - a.getValue().size());
        
        int shown = 0;
        for (Map.Entry<String, Set<String>> entry : sorted) {
            if (shown++ >= 30) break;
            
            String funcName = entry.getKey();
            Set<String> calls = entry.getValue();
            
            // Count interesting calls
            int interestingCalls = 0;
            for (String called : calls) {
                for (String prefix : KEY_PREFIXES) {
                    if (called.startsWith(prefix)) {
                        interestingCalls++;
                        break;
                    }
                }
            }
            
            if (interestingCalls >= 2) {
                output.println(String.format("%s (calls %d functions, %d interesting)", 
                              funcName, calls.size(), interestingCalls));
                for (String called : calls) {
                    output.println("  -> " + called);
                }
                output.println();
            }
        }
    }
    
    private void generateSummary() throws Exception {
        File summaryFile = new File(getProgramFile().getParentFile(), "coa_xref_hooks.h");
        PrintWriter header = new PrintWriter(new FileWriter(summaryFile));
        
        header.println("/**");
        header.println(" * Call to Arms: Cross-Reference Based Hook Points");
        header.println(" * Auto-generated by CrossReferenceAnalyzer.java");
        header.println(" * These are \"hub\" functions that connect to many subsystems");
        header.println(" */");
        header.println();
        header.println("#pragma once");
        header.println("#include <cstdint>");
        header.println();
        header.println("namespace COA {");
        header.println("namespace XRefHooks {");
        header.println();
        
        // Output top hub functions
        header.println("// Hub functions (call many subsystems)");
        List<Map.Entry<String, Set<String>>> byCallCount = new ArrayList<>();
        for (Map.Entry<String, Set<String>> entry : callsTo.entrySet()) {
            byCallCount.add(entry);
        }
        byCallCount.sort((a, b) -> b.getValue().size() - a.getValue().size());
        
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        Address baseAddr = currentProgram.getImageBase();
        
        int count = 0;
        for (Map.Entry<String, Set<String>> entry : byCallCount) {
            if (count++ >= 20) break;
            
            String funcName = entry.getKey();
            int numCalls = entry.getValue().size();
            
            // Find the function address
            for (Function func : funcMgr.getFunctions(true)) {
                if (func.getName().equals(funcName)) {
                    long offset = func.getEntryPoint().subtract(baseAddr);
                    String safeName = funcName.replaceAll("[^a-zA-Z0-9_]", "_").toUpperCase();
                    header.println(String.format("constexpr uintptr_t %s = 0x%08X; // calls %d funcs",
                                  safeName, offset, numCalls));
                    break;
                }
            }
        }
        
        header.println();
        header.println("} // namespace XRefHooks");
        header.println("} // namespace COA");
        
        header.close();
        println("Generated: " + summaryFile.getAbsolutePath());
    }
}
