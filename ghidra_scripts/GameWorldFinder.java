// GameWorldFinder.java - Find the global GameWorld/GameManager singleton
// Run in Ghidra's Script Manager
//
// Strategy:
// 1. Find strings like "game", "world", "manager", "singleton"
// 2. Look for global pointer patterns (mov rax, [rip+offset])
// 3. Find constructors that store 'this' to a global
// 4. Track references to find the main game state object
//
// @category Analysis
// @author COA Script Extender Project

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.address.*;
import ghidra.program.model.mem.*;
import ghidra.program.model.lang.*;
import ghidra.program.model.pcode.*;
import java.util.*;
import java.io.*;

public class GameWorldFinder extends GhidraScript {

    private PrintWriter output;
    private Set<Address> candidateGlobals = new HashSet<>();
    private Map<Address, String> globalDescriptions = new HashMap<>();
    
    // Strings that suggest game state singletons
    private static final String[] SINGLETON_HINTS = {
        "game", "world", "manager", "instance", "singleton",
        "global", "main", "core", "engine", "state",
        "session", "match", "battle", "scenario", "mission",
        "player", "team", "faction", "side",
        "unit", "entity", "object", "actor",
        "map", "terrain", "level", "scene"
    };
    
    // Patterns for singleton access (x64)
    // mov rax, [rip + offset] - common singleton getter pattern
    // lea rax, [rip + offset] - getting address of global
    
    @Override
    public void run() throws Exception {
        File outputFile = new File(getProgramFile().getParentFile(), "coa_gameworld_candidates.txt");
        output = new PrintWriter(new FileWriter(outputFile));
        
        println("===========================================");
        println("GameWorldFinder - Hunting for Game Singletons");
        println("===========================================");
        
        output.println("# Call to Arms: GameWorld/Manager Candidates");
        output.println("# Generated by GameWorldFinder.java");
        output.println();
        
        // Method 1: Find strings and trace to globals
        println("Phase 1: Searching for singleton-related strings...");
        findSingletonStrings();
        
        // Method 2: Find global pointer patterns in .data/.bss
        println("Phase 2: Analyzing global data sections...");
        findGlobalPointers();
        
        // Method 3: Find functions that look like GetInstance()
        println("Phase 3: Finding GetInstance-style functions...");
        findGetInstanceFunctions();
        
        // Method 4: Find constructors storing to globals
        println("Phase 4: Finding singleton constructors...");
        findSingletonConstructors();
        
        // Output results
        output.println();
        output.println("========================================");
        output.println("CANDIDATE GLOBAL POINTERS");
        output.println("========================================");
        output.println();
        
        List<Address> sorted = new ArrayList<>(candidateGlobals);
        Collections.sort(sorted);
        
        for (Address addr : sorted) {
            String desc = globalDescriptions.getOrDefault(addr, "Unknown");
            String offset = formatOffset(addr);
            output.println(String.format("0x%s = %s", offset, desc));
            output.println(String.format("  Full address: %s", addr.toString()));
            
            // Try to identify the type by checking references
            analyzeGlobalType(addr);
            output.println();
        }
        
        output.println();
        output.println("========================================");
        output.println("SUMMARY");
        output.println("========================================");
        output.println("Total candidate globals found: " + candidateGlobals.size());
        
        output.close();
        
        println();
        println("===========================================");
        println("COMPLETE! Found " + candidateGlobals.size() + " candidates");
        println("Results: " + outputFile.getAbsolutePath());
        println("===========================================");
    }
    
    private void findSingletonStrings() throws Exception {
        Memory memory = currentProgram.getMemory();
        ReferenceManager refMgr = currentProgram.getReferenceManager();
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        
        for (String hint : SINGLETON_HINTS) {
            byte[] searchBytes = hint.toLowerCase().getBytes();
            Address startAddr = currentProgram.getMinAddress();
            
            while (startAddr != null && !monitor.isCancelled()) {
                Address found = memory.findBytes(startAddr, searchBytes, null, true, monitor);
                if (found == null) break;
                
                // Check if this looks like a real string (printable chars around it)
                if (isValidString(found)) {
                    // Find functions referencing this string
                    ReferenceIterator refs = refMgr.getReferencesTo(found);
                    while (refs.hasNext()) {
                        Reference ref = refs.next();
                        Function func = funcMgr.getFunctionContaining(ref.getFromAddress());
                        if (func != null) {
                            // Analyze this function for global pointer access
                            analyzeForGlobals(func, hint);
                        }
                    }
                }
                
                startAddr = found.add(1);
            }
        }
        
        output.println("# Found " + candidateGlobals.size() + " candidates from string analysis");
    }
    
    private boolean isValidString(Address addr) {
        try {
            Memory mem = currentProgram.getMemory();
            // Check a few bytes before and after
            for (int i = -2; i < 10; i++) {
                byte b = mem.getByte(addr.add(i));
                if (b == 0) return true; // null terminator is fine
                if (b < 0x20 || b > 0x7E) return false; // non-printable
            }
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    private void analyzeForGlobals(Function func, String context) throws Exception {
        // Look for instructions that access global pointers
        // Pattern: mov reg, [rip + offset] or lea reg, [rip + offset]
        
        InstructionIterator instIter = currentProgram.getListing().getInstructions(func.getBody(), true);
        
        while (instIter.hasNext() && !monitor.isCancelled()) {
            Instruction inst = instIter.next();
            String mnemonic = inst.getMnemonicString().toLowerCase();
            
            if (mnemonic.equals("mov") || mnemonic.equals("lea")) {
                // Check for RIP-relative addressing
                int numOps = inst.getNumOperands();
                for (int i = 0; i < numOps; i++) {
                    Reference[] refs = inst.getOperandReferences(i);
                    for (Reference ref : refs) {
                        if (ref.getReferenceType().isData()) {
                            Address target = ref.getToAddress();
                            // Check if this is in a data section
                            MemoryBlock block = currentProgram.getMemory().getBlock(target);
                            if (block != null && !block.isExecute()) {
                                candidateGlobals.add(target);
                                String desc = context + " (from " + func.getName() + ")";
                                if (!globalDescriptions.containsKey(target)) {
                                    globalDescriptions.put(target, desc);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    private void findGlobalPointers() throws Exception {
        // Look in .data and .bss sections for pointer-sized values
        // that look like they could be singleton pointers
        
        output.println();
        output.println("========================================");
        output.println("DATA SECTION ANALYSIS");
        output.println("========================================");
        output.println();
        
        for (MemoryBlock block : currentProgram.getMemory().getBlocks()) {
            String name = block.getName().toLowerCase();
            if (name.contains("data") || name.contains("bss")) {
                output.println("Section: " + block.getName() + 
                              " @ " + block.getStart() + 
                              " - " + block.getEnd());
                
                // Look for referenced pointers in this section
                Address addr = block.getStart();
                Address end = block.getEnd();
                ReferenceManager refMgr = currentProgram.getReferenceManager();
                
                int count = 0;
                while (addr.compareTo(end) < 0 && count < 1000 && !monitor.isCancelled()) {
                    ReferenceIterator refs = refMgr.getReferencesTo(addr);
                    int refCount = 0;
                    while (refs.hasNext()) {
                        refs.next();
                        refCount++;
                    }
                    
                    // Globals with many references are interesting
                    if (refCount >= 5) {
                        candidateGlobals.add(addr);
                        globalDescriptions.put(addr, "Highly referenced global (" + refCount + " refs)");
                        count++;
                    }
                    
                    addr = addr.add(8); // 64-bit pointers
                }
            }
        }
    }
    
    private void findGetInstanceFunctions() throws Exception {
        // Look for small functions that just return a global pointer
        // Pattern: mov rax, [global]; ret
        
        output.println();
        output.println("========================================");
        output.println("GETINSTANCE-STYLE FUNCTIONS");
        output.println("========================================");
        output.println();
        
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        FunctionIterator funcIter = funcMgr.getFunctions(true);
        
        int found = 0;
        while (funcIter.hasNext() && !monitor.isCancelled()) {
            Function func = funcIter.next();
            
            // Small functions (likely getters)
            long size = func.getBody().getNumAddresses();
            if (size > 20) continue; // Too big
            
            // Check if it's just loading and returning a global
            InstructionIterator instIter = currentProgram.getListing().getInstructions(func.getBody(), true);
            
            boolean hasMov = false;
            boolean hasRet = false;
            Address globalAddr = null;
            
            while (instIter.hasNext()) {
                Instruction inst = instIter.next();
                String mnemonic = inst.getMnemonicString().toLowerCase();
                
                if (mnemonic.equals("mov") || mnemonic.equals("lea")) {
                    Reference[] refs = inst.getOperandReferences(1);
                    for (Reference ref : refs) {
                        if (ref.getReferenceType().isData()) {
                            globalAddr = ref.getToAddress();
                            hasMov = true;
                        }
                    }
                } else if (mnemonic.equals("ret")) {
                    hasRet = true;
                }
            }
            
            if (hasMov && hasRet && globalAddr != null) {
                // This looks like a GetInstance function
                candidateGlobals.add(globalAddr);
                String desc = "GetInstance pattern (func: " + func.getName() + ")";
                globalDescriptions.put(globalAddr, desc);
                
                output.println("Getter: " + func.getName() + " @ " + func.getEntryPoint());
                output.println("  Returns global: " + globalAddr);
                found++;
                
                if (found > 100) break; // Limit output
            }
        }
        
        output.println("# Found " + found + " GetInstance-style functions");
    }
    
    private void findSingletonConstructors() throws Exception {
        // Look for functions that store 'this' (rcx on x64 Windows) to a global
        // Pattern: mov [global], rcx
        
        output.println();
        output.println("========================================");
        output.println("SINGLETON CONSTRUCTORS");
        output.println("========================================");
        output.println();
        
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        FunctionIterator funcIter = funcMgr.getFunctions(true);
        
        int found = 0;
        while (funcIter.hasNext() && found < 50 && !monitor.isCancelled()) {
            Function func = funcIter.next();
            
            InstructionIterator instIter = currentProgram.getListing().getInstructions(func.getBody(), true);
            
            while (instIter.hasNext()) {
                Instruction inst = instIter.next();
                String mnemonic = inst.getMnemonicString().toLowerCase();
                
                // Look for: mov [global], reg (storing this pointer)
                if (mnemonic.equals("mov")) {
                    int numOps = inst.getNumOperands();
                    if (numOps >= 2) {
                        String op0 = inst.getDefaultOperandRepresentation(0);
                        String op1 = inst.getDefaultOperandRepresentation(1);
                        
                        // Check if storing rcx/rdi (this pointer on Win64/Linux64)
                        if (op1.equalsIgnoreCase("rcx") || op1.equalsIgnoreCase("rdi")) {
                            Reference[] refs = inst.getOperandReferences(0);
                            for (Reference ref : refs) {
                                if (ref.getReferenceType().isData()) {
                                    Address target = ref.getToAddress();
                                    MemoryBlock block = currentProgram.getMemory().getBlock(target);
                                    if (block != null && !block.isExecute()) {
                                        candidateGlobals.add(target);
                                        String desc = "Constructor stores 'this' (func: " + func.getName() + ")";
                                        globalDescriptions.put(target, desc);
                                        
                                        output.println("Constructor: " + func.getName());
                                        output.println("  Stores this to: " + target);
                                        found++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        output.println("# Found " + found + " singleton constructors");
    }
    
    private void analyzeGlobalType(Address addr) {
        // Try to determine what kind of object this global points to
        ReferenceManager refMgr = currentProgram.getReferenceManager();
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        
        Set<String> contextHints = new HashSet<>();
        
        ReferenceIterator refs = refMgr.getReferencesTo(addr);
        int refCount = 0;
        while (refs.hasNext() && refCount < 20) {
            Reference ref = refs.next();
            Function func = funcMgr.getFunctionContaining(ref.getFromAddress());
            if (func != null) {
                String funcName = func.getName().toLowerCase();
                for (String hint : SINGLETON_HINTS) {
                    if (funcName.contains(hint)) {
                        contextHints.add(hint);
                    }
                }
            }
            refCount++;
        }
        
        if (!contextHints.isEmpty()) {
            output.println("  Context hints: " + String.join(", ", contextHints));
        }
        output.println("  Reference count: " + refCount + "+");
    }
    
    private String formatOffset(Address addr) {
        String full = addr.toString();
        // Convert 140XXXXXX to offset
        if (full.startsWith("140")) {
            return "0" + full.substring(3);
        } else if (full.startsWith("14")) {
            return full.substring(2);
        }
        return full;
    }
}
