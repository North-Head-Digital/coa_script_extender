// StructureVerifier.java - Analyze functions to verify/refine structure layouts
// Run in Ghidra's Script Manager
//
// This script:
// 1. Analyzes functions that access known structures
// 2. Tracks field access patterns to determine types
// 3. Outputs refined structure definitions
//
// @category Analysis
// @author COA Script Extender Project

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.address.*;
import ghidra.program.model.lang.*;
import ghidra.program.model.scalar.*;
import java.util.*;
import java.io.*;

public class StructureVerifier extends GhidraScript {

    private PrintWriter output;
    
    // Map of offset -> access info
    private Map<Integer, FieldAccess> fieldAccesses = new TreeMap<>();
    
    // Structure to track field access patterns
    static class FieldAccess {
        int offset;
        Set<String> accessTypes = new HashSet<>(); // "read", "write", "ptr_deref", etc.
        Set<String> dataTypes = new HashSet<>();   // Inferred types
        Set<String> usedIn = new HashSet<>();      // Function names
        int accessCount = 0;
        
        FieldAccess(int offset) {
            this.offset = offset;
        }
    }
    
    // Key function addresses to analyze (from our discoveries)
    // These are functions that heavily use game structures
    private static final long[] KEY_FUNCTIONS = {
        0x07ddd90,  // Parse_Damage_Stats
        0x098e800,  // Parse_Vehicle_MaxSpeed
        0x0afbbc0,  // AI_Sensing / Parse_Weapon_Accuracy
        0x03e90c0,  // Parse_Armor_Values
        0x091b240,  // AI_Driver_System
        0x0195d70,  // AI_Movement_Controller
        0x00a7830,  // AI_State_Machine
        0x02419f0,  // AI_Update
        0x0b5fa50,  // AI_Attack_Behavior
        0x00d5c90,  // AI_Defense_Behavior
        0x0383e20,  // AI_Threat_Assessment
        0x01c9720,  // AI_Task_System
        0x01dd220,  // AI_Objective_Handler
    };

    // Output directory - change this to your workspace path
    private static final String OUTPUT_DIR = "/home/darkr/coa_script_extender/ghidra_output";

    @Override
    public void run() throws Exception {
        File outDir = new File(OUTPUT_DIR);
        outDir.mkdirs();
        File outputFile = new File(outDir, "coa_structure_analysis.txt");
        output = new PrintWriter(new FileWriter(outputFile));
        
        println("===========================================");
        println("StructureVerifier - Analyzing Field Access");
        println("===========================================");
        
        output.println("# Call to Arms: Structure Field Analysis");
        output.println("# Generated by StructureVerifier.java");
        output.println("# This refines structure definitions based on actual usage");
        output.println();
        
        Address baseAddr = currentProgram.getImageBase();
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        
        // Analyze each key function
        for (long offset : KEY_FUNCTIONS) {
            if (monitor.isCancelled()) break;
            
            Address funcAddr = baseAddr.add(offset);
            Function func = funcMgr.getFunctionAt(funcAddr);
            
            if (func == null) {
                // Try to find function containing this address
                func = funcMgr.getFunctionContaining(funcAddr);
            }
            
            if (func != null) {
                println("Analyzing: " + func.getName() + " @ 0x" + Long.toHexString(offset));
                analyzeFunction(func);
            } else {
                println("Function not found at 0x" + Long.toHexString(offset));
            }
        }
        
        // Also analyze functions with specific names
        println("\nAnalyzing named functions...");
        analyzeFunctionsByName();
        
        // Output results
        outputResults();
        
        // Generate refined structure header
        generateStructureHeader();
        
        output.close();
        
        println();
        println("===========================================");
        println("COMPLETE!");
        println("Results: " + outputFile.getAbsolutePath());
        println("===========================================");
    }
    
    private void analyzeFunction(Function func) throws Exception {
        InstructionIterator instIter = currentProgram.getListing().getInstructions(func.getBody(), true);
        
        while (instIter.hasNext() && !monitor.isCancelled()) {
            Instruction inst = instIter.next();
            
            // Look for memory access patterns: [reg + offset]
            for (int i = 0; i < inst.getNumOperands(); i++) {
                analyzeOperand(inst, i, func.getName());
            }
        }
    }
    
    private void analyzeOperand(Instruction inst, int opIndex, String funcName) {
        String op = inst.getDefaultOperandRepresentation(opIndex);
        String mnemonic = inst.getMnemonicString().toLowerCase();
        
        // Look for [reg + offset] patterns
        if (op.contains("+") && op.contains("[")) {
            try {
                // Parse offset from operand like [RAX + 0x48]
                int plusIdx = op.indexOf('+');
                int bracketIdx = op.indexOf(']');
                if (plusIdx > 0 && bracketIdx > plusIdx) {
                    String offsetStr = op.substring(plusIdx + 1, bracketIdx).trim();
                    
                    int offset = 0;
                    if (offsetStr.startsWith("0x")) {
                        offset = Integer.parseInt(offsetStr.substring(2), 16);
                    } else if (offsetStr.matches("-?\\d+")) {
                        offset = Integer.parseInt(offsetStr);
                    } else {
                        return; // Can't parse
                    }
                    
                    // Skip very large offsets (likely not structure access)
                    if (offset > 0x1000 || offset < 0) return;
                    
                    // Record this access
                    FieldAccess access = fieldAccesses.computeIfAbsent(offset, FieldAccess::new);
                    access.accessCount++;
                    access.usedIn.add(funcName);
                    
                    // Determine access type
                    if (opIndex == 0) {
                        access.accessTypes.add("write");
                    } else {
                        access.accessTypes.add("read");
                    }
                    
                    // Infer data type from instruction
                    inferDataType(inst, mnemonic, access);
                }
            } catch (Exception e) {
                // Ignore parse errors
            }
        }
        
        // Also check for direct offset in scalars
        Object[] objs = inst.getOpObjects(opIndex);
        for (Object obj : objs) {
            if (obj instanceof Scalar) {
                Scalar scalar = (Scalar) obj;
                long value = scalar.getValue();
                if (value > 0 && value < 0x1000) {
                    // Likely a structure offset
                    FieldAccess access = fieldAccesses.computeIfAbsent((int)value, FieldAccess::new);
                    access.accessCount++;
                    access.usedIn.add(funcName);
                }
            }
        }
    }
    
    private void inferDataType(Instruction inst, String mnemonic, FieldAccess access) {
        // Infer type from instruction
        if (mnemonic.startsWith("movss") || mnemonic.startsWith("addss") || 
            mnemonic.startsWith("subss") || mnemonic.startsWith("mulss") ||
            mnemonic.startsWith("divss") || mnemonic.startsWith("comiss")) {
            access.dataTypes.add("float");
        } else if (mnemonic.startsWith("movsd") || mnemonic.startsWith("addsd")) {
            access.dataTypes.add("double");
        } else if (mnemonic.startsWith("movzx")) {
            access.dataTypes.add("uint8/uint16");
        } else if (mnemonic.startsWith("movsx")) {
            access.dataTypes.add("int8/int16");
        } else if (mnemonic.equals("mov")) {
            // Check operand size
            String op = inst.getDefaultOperandRepresentation(0);
            if (op.contains("eax") || op.contains("ebx") || op.contains("ecx") || op.contains("edx")) {
                access.dataTypes.add("int32/uint32");
            } else if (op.contains("rax") || op.contains("rbx") || op.contains("rcx") || op.contains("rdx")) {
                access.dataTypes.add("int64/pointer");
            } else if (op.contains("al") || op.contains("bl") || op.contains("cl") || op.contains("dl")) {
                access.dataTypes.add("int8/uint8");
            } else if (op.contains("ax") || op.contains("bx") || op.contains("cx") || op.contains("dx")) {
                access.dataTypes.add("int16/uint16");
            }
        } else if (mnemonic.equals("lea")) {
            access.dataTypes.add("pointer/address");
        } else if (mnemonic.equals("test") || mnemonic.equals("cmp")) {
            access.accessTypes.add("comparison");
        } else if (mnemonic.equals("call")) {
            access.dataTypes.add("function_ptr");
        }
    }
    
    private void analyzeFunctionsByName() throws Exception {
        FunctionManager funcMgr = currentProgram.getFunctionManager();
        FunctionIterator funcIter = funcMgr.getFunctions(true);
        
        String[] patterns = {"Parse_", "AI_", "Unit_", "Vehicle_", "Weapon_", "Squad_", "Team_"};
        int count = 0;
        
        while (funcIter.hasNext() && count < 200 && !monitor.isCancelled()) {
            Function func = funcIter.next();
            String name = func.getName();
            
            for (String pattern : patterns) {
                if (name.startsWith(pattern)) {
                    analyzeFunction(func);
                    count++;
                    break;
                }
            }
        }
        
        println("Analyzed " + count + " named functions");
    }
    
    private void outputResults() {
        output.println("========================================");
        output.println("FIELD ACCESS ANALYSIS");
        output.println("========================================");
        output.println();
        output.println(String.format("%-8s %-6s %-20s %-30s %s", 
                       "Offset", "Count", "Access", "Inferred Type", "Used In"));
        output.println("-".repeat(100));
        
        for (Map.Entry<Integer, FieldAccess> entry : fieldAccesses.entrySet()) {
            FieldAccess fa = entry.getValue();
            
            String accessStr = String.join("/", fa.accessTypes);
            String typeStr = String.join(" or ", fa.dataTypes);
            if (typeStr.isEmpty()) typeStr = "unknown";
            
            // Limit function list
            String usedIn = String.join(", ", fa.usedIn);
            if (usedIn.length() > 40) {
                usedIn = usedIn.substring(0, 37) + "...";
            }
            
            output.println(String.format("0x%-6X %-6d %-20s %-30s %s",
                          fa.offset, fa.accessCount, accessStr, typeStr, usedIn));
        }
        
        output.println();
        output.println("Total unique offsets: " + fieldAccesses.size());
    }
    
    private void generateStructureHeader() throws Exception {
        File headerFile = new File(OUTPUT_DIR, "coa_structures_refined.h");
        PrintWriter header = new PrintWriter(new FileWriter(headerFile));
        
        header.println("/**");
        header.println(" * Call to Arms: Gates of Hell - Refined Structure Definitions");
        header.println(" * Auto-generated by StructureVerifier.java");
        header.println(" * Based on actual field access patterns in game code");
        header.println(" */");
        header.println();
        header.println("#pragma once");
        header.println("#include <cstdint>");
        header.println();
        
        // Group fields by likely structure (based on offset ranges)
        header.println("// Common game entity base (offsets 0x00 - 0x40)");
        header.println("struct EntityBase {");
        outputStructureFields(header, 0x00, 0x40);
        header.println("};");
        header.println();
        
        header.println("// Unit-specific fields (offsets 0x40 - 0xC0)");
        header.println("struct UnitData {");
        outputStructureFields(header, 0x40, 0xC0);
        header.println("};");
        header.println();
        
        header.println("// Combat/Weapon fields (offsets 0xC0 - 0x100)");
        header.println("struct CombatData {");
        outputStructureFields(header, 0xC0, 0x100);
        header.println("};");
        header.println();
        
        header.println("// Extended fields (offsets 0x100+)");
        header.println("struct ExtendedData {");
        outputStructureFields(header, 0x100, 0x1000);
        header.println("};");
        
        header.close();
        println("Generated refined structures: " + headerFile.getAbsolutePath());
    }
    
    private void outputStructureFields(PrintWriter header, int startOffset, int endOffset) {
        int lastOffset = startOffset;
        
        for (Map.Entry<Integer, FieldAccess> entry : fieldAccesses.entrySet()) {
            int offset = entry.getKey();
            if (offset < startOffset || offset >= endOffset) continue;
            
            FieldAccess fa = entry.getValue();
            
            // Add padding if needed
            if (offset > lastOffset) {
                int gap = offset - lastOffset;
                if (gap > 0 && gap <= 0x100) {
                    header.println(String.format("    uint8_t _pad_%02X[0x%X];", lastOffset, gap));
                }
            }
            
            // Determine best type
            String cType = inferCType(fa);
            int size = getTypeSize(cType);
            
            // Output field
            String comment = String.format("// %d accesses, %s", fa.accessCount, 
                                          String.join("/", fa.accessTypes));
            header.println(String.format("    %-12s field_%02X; %s", cType, offset, comment));
            
            lastOffset = offset + size;
        }
    }
    
    private String inferCType(FieldAccess fa) {
        if (fa.dataTypes.contains("float")) return "float";
        if (fa.dataTypes.contains("double")) return "double";
        if (fa.dataTypes.contains("function_ptr")) return "void*";
        if (fa.dataTypes.contains("pointer/address") || fa.dataTypes.contains("int64/pointer")) return "void*";
        if (fa.dataTypes.contains("int32/uint32")) return "int32_t";
        if (fa.dataTypes.contains("int16/uint16") || fa.dataTypes.contains("uint8/uint16")) return "int16_t";
        if (fa.dataTypes.contains("int8/uint8")) return "int8_t";
        return "uint64_t"; // Default to 64-bit
    }
    
    private int getTypeSize(String cType) {
        switch (cType) {
            case "int8_t":
            case "uint8_t":
                return 1;
            case "int16_t":
            case "uint16_t":
                return 2;
            case "int32_t":
            case "uint32_t":
            case "float":
                return 4;
            default:
                return 8;
        }
    }
}
