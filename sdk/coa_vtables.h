/**
 * Call to Arms: Gates of Hell - Virtual Function Tables
 * Auto-generated by VTableHunter.java, then deduplicated
 * 
 * VTables allow calling virtual methods and identifying object types at runtime.
 */

#pragma once
#include <cstdint>

namespace COA {
namespace VTables {

//=============================================================================
// CORE AI VTABLES
//=============================================================================

// Main AI interface - 678 refs, 3 methods
constexpr uintptr_t AI_Main                        = 0x0fe7858;

// Secondary AI vtables
constexpr uintptr_t AI_Extended                    = 0x0fe6a40;   // 218 refs, 16 methods
constexpr uintptr_t AI_Type3                       = 0x104f0c0;   // AI category
constexpr uintptr_t AI_Type4                       = 0x10cf9e0;   // AI category
constexpr uintptr_t AI_Type5                       = 0x10fde78;   // AI category
constexpr uintptr_t AI_Type6                       = 0x1177a70;   // AI category

//=============================================================================
// AI CONTROLLER VTABLES
//=============================================================================

// Primary AI Controller - 76 refs, 73 methods (main controller with many virtuals!)
constexpr uintptr_t AI_Controller_Full             = 0x0fe8558;

// Other AI Controller variants
constexpr uintptr_t AI_Controller_Simple           = 0x0fea370;   // 143 refs, 4 methods
constexpr uintptr_t AI_Controller_Alt1             = 0x0fe8518;   // 99 refs, 5 methods
constexpr uintptr_t AI_Controller_Alt2             = 0x0fe87d0;   // 76 refs, 4 methods
constexpr uintptr_t AI_Controller_Alt3             = 0x10058c8;   // 48 refs, 31 methods

//=============================================================================
// VEHICLE VTABLES
//=============================================================================

// Vehicle AI - 448 refs, 9 methods
constexpr uintptr_t Vehicle_AI                     = 0x0fe6960;

// Vehicle with Squad control - 148/141 refs, 5 methods
constexpr uintptr_t Vehicle_Squad_Controller1      = 0x0febbc8;
constexpr uintptr_t Vehicle_Squad_Controller2      = 0x0febc08;

//=============================================================================
// MOVEMENT VTABLES
//=============================================================================

// Movement AI Controller - 250 refs, 16 methods
constexpr uintptr_t Movement_Controller            = 0x0fe6ae0;

// Movement AI variants
constexpr uintptr_t Movement_AI_Type1              = 0x10ae858;
constexpr uintptr_t Movement_AI_Type2              = 0x10698c8;

//=============================================================================
// UNIT VTABLES
//=============================================================================

constexpr uintptr_t Unit_Type1                     = 0x10caba0;
constexpr uintptr_t Unit_Type2                     = 0x10d0020;
constexpr uintptr_t Unit_Type3                     = 0x10d0070;
constexpr uintptr_t Unit_Type4                     = 0x10d00a8;
constexpr uintptr_t Unit_Type5                     = 0x10d00e0;
constexpr uintptr_t Unit_Type6                     = 0x10d0118;
constexpr uintptr_t Unit_Type7                     = 0x0ffa588;

//=============================================================================
// TEAM VTABLES
//=============================================================================

constexpr uintptr_t Team_Type1                     = 0x102fec0;   // 41 refs, 4 methods
constexpr uintptr_t Team_Type2                     = 0x10fd1c8;   // AI_Team
constexpr uintptr_t Team_Type3                     = 0x10fd268;   // AI_Team
constexpr uintptr_t Team_Type4                     = 0x0fe4760;   // AI_Team
constexpr uintptr_t Team_Type5                     = 0x0fe4960;   // AI_Team
constexpr uintptr_t Team_Type6                     = 0x10fd218;   // AI_Team
constexpr uintptr_t Team_Type7                     = 0x10e5fd0;   // AI_Team

//=============================================================================
// HEAVILY REFERENCED UNKNOWN VTABLES (need more analysis)
//=============================================================================

constexpr uintptr_t Unknown_High1                  = 0x0fe78d8;   // 1398 refs, 4 methods
constexpr uintptr_t Unknown_High2                  = 0x113e308;   // 860 refs, 3 methods
constexpr uintptr_t Unknown_High3                  = 0x0fe79b0;   // 624 refs, 3 methods
constexpr uintptr_t Unknown_High4                  = 0x0ff4900;   // 406 refs, 4 methods
constexpr uintptr_t Unknown_High5                  = 0x113e0f8;   // 320 refs, 3 methods
constexpr uintptr_t Unknown_High6                  = 0x10049b8;   // 238 refs, 4 methods
constexpr uintptr_t Unknown_High7                  = 0x113f710;   // 234 refs, 3 methods
constexpr uintptr_t Unknown_High8                  = 0x0fe7900;   // 228 refs, 9 methods
constexpr uintptr_t Unknown_High9                  = 0x0fe7950;   // 228 refs, 11 methods
constexpr uintptr_t Unknown_High10                 = 0x0fffe50;   // 228 refs, 10 methods

// Large vtables (many virtual methods - likely important base classes)
constexpr uintptr_t Large_VTable_1                 = 0x0fea8a0;   // 130 refs, 69 methods!
constexpr uintptr_t Large_VTable_2                 = 0x105ad80;   // 40 refs, 76 methods!
constexpr uintptr_t Large_VTable_3                 = 0x0ff2330;   // 34 refs, 75 methods
constexpr uintptr_t Large_VTable_4                 = 0x0fe98d8;   // 74 refs, 72 methods
constexpr uintptr_t Large_VTable_5                 = 0x0ffcc38;   // 60 refs, 70 methods
constexpr uintptr_t Large_VTable_6                 = 0x10e4bd0;   // 46 refs, 70 methods
constexpr uintptr_t Large_VTable_7                 = 0x1143f08;   // 84 refs, 39 methods

//=============================================================================
// VTABLE UTILITIES
//=============================================================================

// Get vtable pointer from an object
inline uintptr_t GetVTable(void* object) {
    if (!object) return 0;
    return *reinterpret_cast<uintptr_t*>(object);
}

// Check if object has a specific vtable
inline bool HasVTable(void* object, uintptr_t gameBase, uintptr_t vtableOffset) {
    return GetVTable(object) == (gameBase + vtableOffset);
}

// Get virtual function pointer from vtable
inline void* GetVirtualFunction(void* object, int index) {
    if (!object) return nullptr;
    uintptr_t* vtable = *reinterpret_cast<uintptr_t**>(object);
    return reinterpret_cast<void*>(vtable[index]);
}

// Call virtual function by index
template<typename RetType, typename... Args>
inline RetType CallVirtual(void* object, int index, Args... args) {
    typedef RetType (*VirtualFn)(void*, Args...);
    VirtualFn fn = reinterpret_cast<VirtualFn>(GetVirtualFunction(object, index));
    return fn(object, args...);
}

} // namespace VTables
} // namespace COA

//=============================================================================
// CONVENIENCE MACROS
//=============================================================================

// Check object type by vtable
#define COA_IS_TYPE(obj, vtableOffset) \
    COA::VTables::HasVTable(obj, g_GameBase, vtableOffset)

// Call virtual method
#define COA_CALL_VIRTUAL(RetType, obj, index, ...) \
    COA::VTables::CallVirtual<RetType>(obj, index, ##__VA_ARGS__)
